%!TEX root = thesis.tex
\hypertarget{the-wrapper}{%
\section{The wrapper}\label{the-wrapper}}

This chapter describes the Python-wrapper `wrapper.py' in more detail.
Since it is not the focus of the present paper this chapter is kept
shorter than the documentation about the C-core implementing AES.

In general the wrapper is supposed to prepare data and to provide an
interface for the C-core. It is the entry point to the program. The
basic functionality from a user perspective can be broken down into 3
components.

\hypertarget{compiling-the-c-core}{%
\subsection{Compiling the C-core}\label{compiling-the-c-core}}

To guarantee optimal performance and portability the present
implementation compiles the C-source code into linkable binaries on
first startup. The program does get delivered with an empty lib-folder.
On startup, the program tries to link the libraries containing the AES
C-code compiled to binaries from the lib-folder. If it cannot detect
them, it tries to compile them by communicating over the Python
subprocess-library with Clang or GCC. A successful compilation
guarantees that the C-core is able to run on the platform it was
compiled to. Furthermore the compiler may be able to leverage platform
specific optimizations if they are available \footnote{This is mainly accomplished through the \lstinline{-march='native'} flag}. Since compilation time is
short and done only once it is a reasonable way to ensure portability
and performance. Finally it made testing changes to the C-code easier,
since one only has to delete the old library files and run the program
again to trigger a recompile.

\hypertarget{en--and-decryption}{%
\subsection{en- and decryption}\label{en--and-decryption}}

The C-code, once it is compiled to a .so-file, can be dynamically linked
with the Python standard-library ctypes. This allows calling C functions
directly from Python and passing pointers to Python byte arrays. Those
byte arrays can be modified by the called C-code. The wrapper
calls the en- and decrypt functions of the C implementations via the two
python functions ``encrypt'' and ``decrypt'', that both take the byte
array that is supposed to be processed and the expanded keys. The two
functions then prepare the arrays for the ctypes interface and pass them
on to the C-function for en- and decryption, along with the initvals,
which consists of the values for the S-box and the values of the GFMLT
(both generated at program startup) concatenated with the expanded keys.
Since the C-core modifies the byte arrays in place they just get
returned, after the C-function returns.

\hypertarget{interface}{%
\subsection{Interface}\label{interface}}

There are four functions through which the user interacts with the
program: two for text operations and two for file operations. All four
get exposed to the user via the `click'-library, which a following
chapter will explain in more depth. This library passes on the arguments
from the command line to the function it decorates. ITERATION

The text functions, called `te' for `\textbf{t}ext \textbf{e}ncrypt" and
'td' for `\textbf{t}ext \textbf{d}ecrypt' via the command line, simply
encode the received text into a byte array (and add padding or remove
it), expand the key, call the matching en- or decryption function with
both of those arrays and return either the encrypted text in hex or the
decrypted text in utf-8 encoding.

The file functions, called `fe' for `\textbf{f}ile \textbf{e}ncrypt" and
'fd' for `\textbf{f}ext \textbf{d}ecrypt' via the command line, work in
a similar way. They also expand the key, but additionally prepare an
outputfile, by either adding or removing the ``.enc''-file-ending. They
open both the input and output file simultaneously. This helps with very
large files, since they can process them chunk by chunk. This allows for
(theoretically) processing files of unbounded file sizes, since the
program is not limited by the systems RAM. For every chunk the program
reads, it checks if the read length is shorter than the defined length
of a chunk. If that is the case, the program knows, that this is the
last chunk of the file. It either pads the last chunk (in case of
encryption) or removes the padding (in case of decryption), terminates
the read-loop and writes them to disk with the other chunks. During the
process the chunks themselves get passed on to the respective en- or
decryption function, along with the expanded keys.
